//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:4.0.30319.18444
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
using System;
using UnityEngine;
public class DualCalculator
{
	private static DualCalculator instance  = new DualCalculator();
	private const float FACTOR = 0.02f;
	private DualCalculator ()
	{
	}
	public static DualCalculator getInstance()
	{
		return instance;
	}
	private int getElementsRelation(int attackerElement, int defenserElement)
	{
		int result = 0;
		switch(attackerElement)
		{
			case UnitTypes.WATERELEMENT:
				if(defenserElement==UnitTypes.FIREELEMENT)
				result=1;
				else if(defenserElement==UnitTypes.WOODELEMENT)
				result=-1;
				break;
			case UnitTypes.FIREELEMENT:
				if(defenserElement==UnitTypes.WOODELEMENT)
				result=1;
				else if(defenserElement==UnitTypes.WATERELEMENT)
				result=-1;
			break;
			case UnitTypes.WOODELEMENT:
				if(defenserElement==UnitTypes.WATERELEMENT)
				result=1;
				else if(defenserElement==UnitTypes.FIREELEMENT)
				result=-1;
			break;
		}
		return result;
	}
	public float getDamage(UnitBase attacker, UnitBase defenser)
	{
		float attackPower = attacker.getAttackPower (defenser);
//		Debug.Log (attacker.unitType+",attackPower is:"+ attackPower);
		float defensePower = defenser.getDefensePower (attacker);
//		Debug.Log (defenser.unitType+",defensePower is:"+ defensePower);
		float damage = attackPower / (1+FACTOR*defensePower);
		int elementRelation = getElementsRelation (attacker.elementType,defenser.elementType);
		if (elementRelation > 0)
			damage = damage * 1.0f;
		else if(elementRelation<0)
			damage = damage * 1.0f;
//		Debug.Log (attacker.unitType+",criticalNumber is:"+ criticalNumber);
//		if (criticalNumber < attacker.getCriticalRate ()) 
//		{
//			damage *= attacker.getCriticalFactor ();
//			if(attacker.unitType==UnitTypes.ARCHER)
//			{
//				attacker.setCoolDownFactor(attacker.getCoolDownFactor()+0.5f);
//			}
//			else if(attacker.unitType==UnitTypes.TANK)
//			{
//				attacker.setHP(attacker.getHP()+damage*0.5f);
//			}
//		}
		return damage;
	}

	public float getDamage(SkillConfiguration.SkillData skillData, UnitBase defender)
	{
		float resultDamage = UnityEngine.Random.Range(200.0f, 400.0f);
		return resultDamage;
	}

	public float getHeal(SkillConfiguration.SkillData skillData, UnitBase receiver)
	{
		float resultHealing = UnityEngine.Random.Range(200.0f, 400.0f);
		return resultHealing;
	}

	public bool isCritical(UnitBase attacker)
	{
		int criticalNumber = UnityEngine.Random.Range (1,101);
		return criticalNumber < attacker.getCriticalRate ();
	}
}

